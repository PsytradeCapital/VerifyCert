import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { BrowserRouter } from 'react-router-dom';
import { FeedbackProvider } from '../contexts/FeedbackContext';
import { FeedbackCollector } from '../components/ui/Feedback/FeedbackCollector';
import { FeedbackButton } from '../components/ui/Feedback/FeedbackButton';
import { FeedbackDashboard } from '../components/ui/Feedback/FeedbackDashboard';
import { feedbackService } from '../services/feedbackService';

// Mock framer-motion to avoid animation issues in tests
jest.mock('framer-motion', () => ({
  motion: {
    div: (props: any) => React.createElement('div', props),
    button: (props: any) => React.createElement('button', props),
  },
  AnimatePresence: (props: any) => props.children,
}));

// Mock window.gtag
(window as any).gtag = jest.fn();

interface TestWrapperProps {
  children: React.ReactNode;
}

const TestWrapper: React.FC<TestWrapperProps> = ({ children }) => (
  <BrowserRouter>
    <FeedbackProvider>
      {children}
    </FeedbackProvider>
  </BrowserRouter>
);

describe('Feedback System', () => {
  beforeEach(() => {
    // Clear localStorage before each test
    localStorage.clear();
    jest.clearAllMocks();
  });

  describe('FeedbackCollector', () => {
    it('renders feedback collector when open', () => {
      render(
        <TestWrapper>
          <FeedbackCollector
            isOpen={true}
            onClose={jest.fn()}
            category="overall-experience"
          />
        </TestWrapper>
      );

      expect(screen.getByText('Share Your Feedback')).toBeInTheDocument();
      expect(screen.getByText('Overall Experience')).toBeInTheDocument();
    });

    it('does not render when closed', () => {
      render(
        <TestWrapper>
          <FeedbackCollector
            isOpen={false}
            onClose={jest.fn()}
            category="overall-experience"
          />
        </TestWrapper>
      );

      expect(screen.queryByText('Share Your Feedback')).not.toBeInTheDocument();
    });

    it('allows user to select rating and submit feedback', async () => {
      const user = userEvent.setup();
      const onClose = jest.fn();

      render(
        <TestWrapper>
          <FeedbackCollector
            isOpen={true}
            onClose={onClose}
            category="navigation"
          />
        </TestWrapper>
      );

      // Select navigation category
      const navigationOption = screen.getByLabelText(/Navigation & User Flow/);
      await user.click(navigationOption);

      // Select 4-star rating
      const fourthStar = screen.getAllByLabelText(/Rate \d out of 5 stars/)[3];
      await user.click(fourthStar);

      // Enter feedback text
      const feedbackTextarea = screen.getByPlaceholderText(/What did you like/);
      await user.type(feedbackTextarea, 'The navigation is intuitive and easy to use.');

      // Submit feedback
      const submitButton = screen.getByText('Send Feedback');
      await user.click(submitButton);

      // Wait for submission
      await waitFor(() => {
        expect(onClose).toHaveBeenCalled();
      });

      // Verify feedback was stored
      const storedFeedback = JSON.parse(localStorage.getItem('verifycert-feedback') || '[]');
      expect(storedFeedback).toHaveLength(1);
      expect(storedFeedback[0]).toMatchObject({
        category: 'navigation',
        rating: 4,
        feedback: 'The navigation is intuitive and easy to use.',
      });
    });

    it('validates required fields', async () => {
      const user = userEvent.setup();

      render(
        <TestWrapper>
          <FeedbackCollector
            isOpen={true}
            onClose={jest.fn()}
            category="visual-design"
          />
        </TestWrapper>
      );

      const submitButton = screen.getByText('Send Feedback');
      
      // Try to submit without rating or feedback
      expect(submitButton).toBeDisabled();

      // Add rating but no feedback
      const firstStar = screen.getAllByLabelText(/Rate \d out of 5 stars/)[0];
      await user.click(firstStar);
      
      expect(submitButton).toBeDisabled();

      // Add feedback
      const feedbackTextarea = screen.getByPlaceholderText(/What did you like/);
      await user.type(feedbackTextarea, 'Great design!');

      expect(submitButton).not.toBeDisabled();
    });

    it('shows different categories correctly', () => {
      const categories = ['navigation', 'visual-design', 'overall-experience'] as const;

      categories.forEach(category => {
        const { unmount } = render(
          <TestWrapper>
            <FeedbackCollector
              isOpen={true}
              onClose={jest.fn()}
              category={category}
            />
          </TestWrapper>
        );

        const categoryLabels = {
          'navigation': 'Navigation & User Flow',
          'visual-design': 'Visual Design & Layout',
          'overall-experience': 'Overall Experience'
        };

        expect(screen.getByText(categoryLabels[category])).toBeInTheDocument();
        unmount();
      });
    });
  });

  describe('FeedbackButton', () => {
    it('renders floating feedback button', () => {
      render(
        <TestWrapper>
          <FeedbackButton />
        </TestWrapper>
      );

      expect(screen.getByLabelText('Open feedback form')).toBeInTheDocument();
    });

    it('opens feedback collector when clicked', async () => {
      const user = userEvent.setup();

      render(
        <TestWrapper>
          <FeedbackButton />
        </TestWrapper>
      );

      const button = screen.getByLabelText('Open feedback form');
      await user.click(button);

      expect(screen.getByText('Share Your Feedback')).toBeInTheDocument();
    });

    it('shows hover text on hover', async () => {
      const user = userEvent.setup();

      render(
        <TestWrapper>
          <FeedbackButton />
        </TestWrapper>
      );

      const button = screen.getByLabelText('Open feedback form');
      await user.hover(button);

      expect(screen.getByText('Feedback')).toBeInTheDocument();
    });
  });

  describe('FeedbackService', () => {
    it('stores feedback correctly', () => {
      const feedback = {
        category: 'navigation' as const,
        rating: 5,
        feedback: 'Excellent navigation!',
        page: '/test',
        timestamp: Date.now(),
        userAgent: 'test-agent',
        screenSize: '1920x1080'
      };

      feedbackService.storeFeedback(feedback);

      const stored = feedbackService.getAllFeedback();
      expect(stored).toHaveLength(1);
      expect(stored[0]).toEqual(feedback);
    });

    it('generates analytics correctly', () => {
      // Add some test feedback
      const feedbacks = [
        {
          category: 'navigation' as const,
          rating: 4,
          feedback: 'Good navigation',
          page: '/test1',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
        },
        {
          category: 'visual-design' as const,
          rating: 5,
          feedback: 'Beautiful design',
          page: '/test2',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
        },
        {
          category: 'navigation' as const,
          rating: 2,
          feedback: 'Confusing navigation',
          page: '/test1',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
      ];

      feedbacks.forEach(feedback => feedbackService.storeFeedback(feedback));

      const analytics = feedbackService.getAnalytics();

      expect(analytics.totalFeedback).toBe(3);
      expect(analytics.averageRating).toBe((4 + 5 + 2) / 3);
      expect(analytics.categoryBreakdown).toHaveProperty('navigation');
      expect(analytics.categoryBreakdown).toHaveProperty('visual-design');
      expect(analytics.categoryBreakdown.navigation.count).toBe(2);
      expect(analytics.categoryBreakdown['visual-design'].count).toBe(1);
    });

    it('exports feedback data correctly', () => {
      const feedback = {
        category: 'overall-experience' as const,
        rating: 3,
        feedback: 'Average experience',
        page: '/test',
        timestamp: Date.now(),
        userAgent: 'test-agent',
        screenSize: '1920x1080'
      };

      feedbackService.storeFeedback(feedback);

      const exported = feedbackService.exportFeedback();
      const parsed = JSON.parse(exported);

      expect(parsed).toHaveProperty('exportDate');
      expect(parsed).toHaveProperty('feedback');
      expect(parsed).toHaveProperty('analytics');
      expect(parsed.feedback).toHaveLength(1);
    });

    it('clears feedback data correctly', () => {
      const feedback = {
        category: 'navigation' as const,
        rating: 4,
        feedback: 'Test feedback',
        page: '/test',
        timestamp: Date.now(),
        userAgent: 'test-agent',
        screenSize: '1920x1080'
      };

      feedbackService.storeFeedback(feedback);
      expect(feedbackService.getAllFeedback()).toHaveLength(1);

      feedbackService.clearFeedback();
      expect(feedbackService.getAllFeedback()).toHaveLength(0);
    });

    it('gets page-specific feedback correctly', () => {
      const feedbacks = [
        {
          category: 'navigation' as const,
          rating: 4,
          feedback: 'Good navigation',
          page: '/page1',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
        },
        {
          category: 'visual-design' as const,
          rating: 5,
          feedback: 'Great design',
          page: '/page2',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
        },
        {
          category: 'overall-experience' as const,
          rating: 3,
          feedback: 'OK experience',
          page: '/page1',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
      ];

      feedbacks.forEach(feedback => feedbackService.storeFeedback(feedback));

      const page1Feedback = feedbackService.getPageFeedback('/page1');
      expect(page1Feedback.count).toBe(2);
      expect(page1Feedback.averageRating).toBe((4 + 3) / 2);

      const page2Feedback = feedbackService.getPageFeedback('/page2');
      expect(page2Feedback.count).toBe(1);
      expect(page2Feedback.averageRating).toBe(5);
    });

    it('gets category-specific feedback correctly', () => {
      const feedbacks = [
        {
          category: 'navigation' as const,
          rating: 4,
          feedback: 'Good navigation',
          page: '/test1',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
        },
        {
          category: 'navigation' as const,
          rating: 2,
          feedback: 'Poor navigation',
          page: '/test2',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
        },
        {
          category: 'visual-design' as const,
          rating: 5,
          feedback: 'Excellent design',
          page: '/test1',
          timestamp: Date.now(),
          userAgent: 'test-agent',
          screenSize: '1920x1080'
      ];

      feedbacks.forEach(feedback => feedbackService.storeFeedback(feedback));

      const navigationFeedback = feedbackService.getCategoryFeedback('navigation');
      expect(navigationFeedback.count).toBe(2);
      expect(navigationFeedback.averageRating).toBe((4 + 2) / 2);

      const designFeedback = feedbackService.getCategoryFeedback('visual-design');
      expect(designFeedback.count).toBe(1);
      expect(designFeedback.averageRating).toBe(5);
    });
  });

  describe('FeedbackDashboard', () => {
    it('renders empty state when no feedback', () => {
      render(
        <TestWrapper>
          <FeedbackDashboard />
        </TestWrapper>
      );

      expect(screen.getByText('No Feedback Yet')).toBeInTheDocument();
    });

    it('renders analytics when feedback exists', () => {
      // Add some test feedback
      const feedback = {
        category: 'navigation' as const,
        rating: 4,
        feedback: 'Good navigation',
        page: '/test',
        timestamp: Date.now(),
        userAgent: 'test-agent',
        screenSize: '1920x1080'
      };

      feedbackService.storeFeedback(feedback);

      render(
        <TestWrapper>
          <FeedbackDashboard />
        </TestWrapper>
      );

      expect(screen.getByText('Feedback Analytics')).toBeInTheDocument();
      expect(screen.getByText('Total Feedback')).toBeInTheDocument();
      expect(screen.getByText('Average Rating')).toBeInTheDocument();
    });

    it('allows exporting feedback data', async () => {
      const user = userEvent.setup();

      // Mock URL.createObjectURL and related methods
      const mockCreateObjectURL = jest.fn().mockReturnValue('mock-url');
      const mockRevokeObjectURL = jest.fn();
      global.URL.createObjectURL = mockCreateObjectURL;
      global.URL.revokeObjectURL = mockRevokeObjectURL;

      // Mock document.createElement and appendChild
      const mockAnchor = {
        href: '',
        download: '',
        click: jest.fn(),
      };
      const mockCreateElement = jest.fn().mockReturnValue(mockAnchor);
      const mockAppendChild = jest.fn();
      const mockRemoveChild = jest.fn();
      
      document.createElement = mockCreateElement;
      document.body.appendChild = mockAppendChild;
      document.body.removeChild = mockRemoveChild;

      // Add test feedback
      const feedback = {
        category: 'navigation' as const,
        rating: 4,
        feedback: 'Test feedback',
        page: '/test',
        timestamp: Date.now(),
        userAgent: 'test-agent',
        screenSize: '1920x1080'
      };

      feedbackService.storeFeedback(feedback);

      render(
        <TestWrapper>
          <FeedbackDashboard />
        </TestWrapper>
      );

      const exportButton = screen.getByText('Export');
      await user.click(exportButton);

      expect(mockCreateElement).toHaveBeenCalledWith('a');
      expect(mockAnchor.click).toHaveBeenCalled();
      expect(mockCreateObjectURL).toHaveBeenCalled();
    });
  });
});